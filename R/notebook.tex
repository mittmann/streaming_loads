% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={R Notebook},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering

\title{R Notebook}
\author{}
\date{\vspace{-2.5em}}

\begin{document}
\maketitle

Existem diversas aplicações que não se beneficiam das caches. Quando são
executadas normalmente, causam poluição de cache para as outras
aplicações rodando simultaneamente e consomem energia
desnecessariamente, tanto por fazer uso da cache quando não há
necessidade quanto por causar slowdown das outras aplicações, fazendo o
processador ficar ativo por mais tempo, além de causar mais acessos à
memória devido a poluição de cache, que consomem energia.

Podemos observar primeiramente o slowdown em uma thread de um
microbenchmark que faz leitura e acumulação de um vetor que cabe
confortavelmente na cache quando é executado simultaneamente a uma outra
thread do mesmo benchrmark.

Primeiro um código pra carregar os resultados em um dataframe:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(dplyr)}
\KeywordTok{library}\NormalTok{(tidyr);}
\NormalTok{df <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"../expmat/outputs/08.07.10.mitt.csv"}\NormalTok{);}
\NormalTok{k <-}\StringTok{ }\NormalTok{df }\OperatorTok{%>%}\StringTok{ }\KeywordTok{select}\NormalTok{(sizea,sizeb,temp,cyca,l3ma,l3ra,cycb,l3mb,l3rb) }\OperatorTok{%>%}
\StringTok{ }\KeywordTok{group_by}\NormalTok{(sizea,sizeb,temp) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{mcyca=}\KeywordTok{min}\NormalTok{(cyca), }\DataTypeTok{ml3ma=}\KeywordTok{min}\NormalTok{(l3ma), }\DataTypeTok{ml3ra=}\KeywordTok{min}\NormalTok{(l3ra), }\DataTypeTok{mcycb=}\KeywordTok{min}\NormalTok{(cycb), }\DataTypeTok{ml3mb=}\KeywordTok{min}\NormalTok{(l3mb), }\DataTypeTok{ml3rb=}\KeywordTok{min}\NormalTok{(l3rb), }\DataTypeTok{.groups=}\StringTok{'drop'}\NormalTok{) }\OperatorTok{%>%}\StringTok{  }\KeywordTok{as.data.frame}\NormalTok{()}
\NormalTok{k2 <-}\StringTok{ }\NormalTok{k;}
\NormalTok{k2}\OperatorTok{$}\NormalTok{sizea =}\StringTok{ }\NormalTok{k}\OperatorTok{$}\NormalTok{sizeb; k2}\OperatorTok{$}\NormalTok{sizeb =}\StringTok{ }\NormalTok{k}\OperatorTok{$}\NormalTok{sizea; k2}\OperatorTok{$}\NormalTok{mcyca =}\StringTok{ }\NormalTok{k}\OperatorTok{$}\NormalTok{mcycb; k2}\OperatorTok{$}\NormalTok{mcycb =}\StringTok{ }\NormalTok{k}\OperatorTok{$}\NormalTok{mcyca; }
\NormalTok{k2}\OperatorTok{$}\NormalTok{ml3ra =}\StringTok{ }\NormalTok{k}\OperatorTok{$}\NormalTok{ml3rb; k2}\OperatorTok{$}\NormalTok{ml3rb =}\StringTok{ }\NormalTok{k}\OperatorTok{$}\NormalTok{ml3ra; k2}\OperatorTok{$}\NormalTok{ml3ma =}\StringTok{ }\NormalTok{k}\OperatorTok{$}\NormalTok{ml3mb; k2}\OperatorTok{$}\NormalTok{ml3mb =}\StringTok{ }\NormalTok{k}\OperatorTok{$}\NormalTok{ml3ma;}
\NormalTok{k2}\OperatorTok{$}\NormalTok{temp <-}\StringTok{ }\KeywordTok{replace}\NormalTok{(}\KeywordTok{as.character}\NormalTok{(k2}\OperatorTok{$}\NormalTok{temp), k2}\OperatorTok{$}\NormalTok{temp }\OperatorTok{==}\StringTok{ "nt"}\NormalTok{,}\StringTok{"tmp"}\NormalTok{)}
\NormalTok{k2}\OperatorTok{$}\NormalTok{temp <-}\StringTok{ }\KeywordTok{replace}\NormalTok{(}\KeywordTok{as.character}\NormalTok{(k2}\OperatorTok{$}\NormalTok{temp), k2}\OperatorTok{$}\NormalTok{temp }\OperatorTok{==}\StringTok{ "tn"}\NormalTok{,}\StringTok{"nt"}\NormalTok{)}
\NormalTok{k2}\OperatorTok{$}\NormalTok{temp <-}\StringTok{ }\KeywordTok{replace}\NormalTok{(}\KeywordTok{as.character}\NormalTok{(k2}\OperatorTok{$}\NormalTok{temp), k2}\OperatorTok{$}\NormalTok{temp }\OperatorTok{==}\StringTok{ "tmp"}\NormalTok{,}\StringTok{"tn"}\NormalTok{)}
\NormalTok{combined <-}\StringTok{ }\KeywordTok{rbind}\NormalTok{(k,k2)}
\NormalTok{k <-}\StringTok{ }\KeywordTok{subset}\NormalTok{( combined, }\DataTypeTok{select =} \OperatorTok{-}\KeywordTok{c}\NormalTok{(mcycb,ml3rb,ml3mb));}
\NormalTok{k <-}\StringTok{ }\NormalTok{k }\OperatorTok{%>%}\StringTok{ }\KeywordTok{group_by}\NormalTok{(sizea,sizeb,temp,) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{summarise}\NormalTok{( }\DataTypeTok{mcyca=}\KeywordTok{mean}\NormalTok{(mcyca), }\DataTypeTok{ml3ra=}\KeywordTok{mean}\NormalTok{(ml3ra), }\DataTypeTok{ml3ma=}\KeywordTok{mean}\NormalTok{(ml3ma), }\DataTypeTok{.groups=}\StringTok{'drop'}\NormalTok{);}
\NormalTok{k <-}\StringTok{ }\NormalTok{k }\OperatorTok{%>%}\StringTok{ }\KeywordTok{rename}\NormalTok{ (}\DataTypeTok{cyc =}\NormalTok{ mcyca, }\DataTypeTok{l3r =}\NormalTok{ ml3ra, }\DataTypeTok{l3m =}\NormalTok{ ml3ma)}
\NormalTok{k <-}\StringTok{ }\NormalTok{k[k}\OperatorTok{$}\NormalTok{sizea}\OperatorTok{!=}\DecValTok{0}\NormalTok{,]}
\NormalTok{k <-}\StringTok{ }\NormalTok{k }\OperatorTok{%>%}\StringTok{ }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{sizea =}\NormalTok{ sizea}\OperatorTok{/}\DecValTok{1024}\NormalTok{, }\DataTypeTok{sizeb =}\NormalTok{ sizeb}\OperatorTok{/}\DecValTok{1024}\NormalTok{)}
\KeywordTok{rm}\NormalTok{(combined, k2)}
\KeywordTok{head}\NormalTok{(k)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 6
##   sizea sizeb temp           cyc         l3r     l3m
##   <dbl> <dbl> <chr>        <dbl>       <dbl>   <dbl>
## 1     1     0 nn    26192683123         105      0  
## 2     1     0 nt    26235417668          86      2  
## 3     1     0 tn     5030942956  1048576997  17171  
## 4     1     0 tt     5030948036  1048577042  17159  
## 5     1     1 nn    27616080778         132.     6  
## 6     1     1 nt    26274811372.        138.     2.5
\end{verbatim}

Agora observando a diferença na quantidade de ciclos para executar o
benchmark com 4 MB sozinho ou com outra thread lendo 256 MB
simultaneamente.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k[k}\OperatorTok{$}\NormalTok{temp}\OperatorTok{==}\StringTok{"tt"} \OperatorTok{&}\StringTok{ }\NormalTok{k}\OperatorTok{$}\NormalTok{sizea}\OperatorTok{==}\DecValTok{4} \OperatorTok{&}\StringTok{ }\NormalTok{( k}\OperatorTok{$}\NormalTok{sizeb}\OperatorTok{==}\DecValTok{256} \OperatorTok{|}\StringTok{ }\NormalTok{k}\OperatorTok{$}\NormalTok{sizeb}\OperatorTok{==}\DecValTok{0}\NormalTok{ ),]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 2 x 6
##   sizea sizeb temp         cyc        l3r    l3m
##   <dbl> <dbl> <chr>      <dbl>      <dbl>  <dbl>
## 1     4     0 tt    5003381051 1042188976  73568
## 2     4   256 tt    5112801442 1042192098 107349
\end{verbatim}

A diferença aparentemente é bem pequena. Quem sabe observando com uma
aplicação que caiba com menos folga na cache, como 7MB.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k[k}\OperatorTok{$}\NormalTok{temp}\OperatorTok{==}\StringTok{"tt"} \OperatorTok{&}\StringTok{ }\NormalTok{k}\OperatorTok{$}\NormalTok{sizea}\OperatorTok{==}\DecValTok{7} \OperatorTok{&}\StringTok{ }\NormalTok{( k}\OperatorTok{$}\NormalTok{sizeb}\OperatorTok{==}\DecValTok{256} \OperatorTok{|}\StringTok{ }\NormalTok{k}\OperatorTok{$}\NormalTok{sizeb}\OperatorTok{==}\DecValTok{0}\NormalTok{ ),]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 2 x 6
##   sizea sizeb temp         cyc        l3r     l3m
##   <dbl> <dbl> <chr>      <dbl>      <dbl>   <dbl>
## 1     7     0 tt    5434646021 1126152998  182711
## 2     7   256 tt    5760873248 1126154169 8592174
\end{verbatim}

A diferença é pequena também. Quem sabe 8 MB então?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k[k}\OperatorTok{$}\NormalTok{temp}\OperatorTok{==}\StringTok{"tt"} \OperatorTok{&}\StringTok{ }\NormalTok{k}\OperatorTok{$}\NormalTok{sizea}\OperatorTok{==}\DecValTok{8} \OperatorTok{&}\StringTok{ }\NormalTok{( k}\OperatorTok{$}\NormalTok{sizeb}\OperatorTok{==}\DecValTok{256} \OperatorTok{|}\StringTok{ }\NormalTok{k}\OperatorTok{$}\NormalTok{sizeb}\OperatorTok{==}\DecValTok{0}\NormalTok{ ),]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 2 x 6
##   sizea sizeb temp         cyc       l3r      l3m
##   <dbl> <dbl> <chr>      <dbl>     <dbl>    <dbl>
## 1     8     0 tt    4813527640 919308648 10202847
## 2     8   256 tt    6521674824 919327185 84604598
\end{verbatim}

Nesse caso realmente com a thread de 256 MB há um slowdown
significativo.

De quanto?

Adicionando colunas para as diferenças conforme sizeb aumenta para todos
sizea:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#k <- k %>% group_by(sizea,temp) %>% mutate_each(funs(./.[1]), cyc_diff=cyc, l3r_diff=l3r, l3m_diff=l3m, -sizeb)}
\NormalTok{k_diff <-}\StringTok{ }\NormalTok{k }\OperatorTok{%>%}\StringTok{ }\KeywordTok{group_by}\NormalTok{(sizea) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{mutate_each}\NormalTok{(}\KeywordTok{funs}\NormalTok{(.}\OperatorTok{/}\NormalTok{.[}\DecValTok{4}\NormalTok{]), }\DataTypeTok{cyc_diff=}\NormalTok{cyc, }\DataTypeTok{l3r_diff=}\NormalTok{l3r, }\DataTypeTok{l3m_diff=}\NormalTok{l3m, }\OperatorTok{-}\NormalTok{sizeb)}
\CommentTok{# CUIDADO!! GAMBIARRA ESSE [4]}
\NormalTok{k_diff }\CommentTok{# %>% filter(temp=="nt")# %>% head()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 840 x 9
## # Groups:   sizea [14]
##    sizea sizeb temp          cyc        l3r     l3m cyc_diff   l3r_diff l3m_diff
##    <dbl> <dbl> <chr>       <dbl>      <dbl>   <dbl>    <dbl>      <dbl>    <dbl>
##  1     1     0 nn        2.62e10     1.05e2     0       5.21    1.00e-7 0       
##  2     1     0 nt        2.62e10     8.60e1     2       5.21    8.20e-8 0.000117
##  3     1     0 tn        5.03e 9     1.05e9 17171       1.00    1.00e+0 1.00    
##  4     1     0 tt        5.03e 9     1.05e9 17159       1       1.00e+0 1       
##  5     1     1 nn        2.76e10     1.32e2     6       5.49    1.26e-7 0.000350
##  6     1     1 nt        2.63e10     1.38e2     2.5     5.22    1.32e-7 0.000146
##  7     1     1 tn        5.08e 9     1.05e9 17195       1.01    1.00e+0 1.00    
##  8     1     1 tt        5.10e 9     1.05e9 17160       1.01    1.00e+0 1.00    
##  9     1     2 nn        2.81e10     1.47e2     2       5.58    1.40e-7 0.000117
## 10     1     2 nt        2.63e10     1.62e2     7       5.23    1.54e-7 0.000408
## # ... with 830 more rows
\end{verbatim}

Visualizando os valores para sizea = 8 MB

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(ggplot2)}
\NormalTok{k_diff }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizea}\OperatorTok{==}\DecValTok{8}\NormalTok{, temp }\OperatorTok{==}\StringTok{ "tt"}\NormalTok{, sizeb}\OperatorTok{!=}\DecValTok{0}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ungroup}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }\KeywordTok{select}\NormalTok{(sizeb,cyc_diff) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\KeywordTok{as.factor}\NormalTok{(sizeb), }\DataTypeTok{y=}\NormalTok{cyc_diff)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{   }\KeywordTok{theme_bw}\NormalTok{() }\OperatorTok{+}\StringTok{ }\KeywordTok{xlab}\NormalTok{(}\StringTok{"sizeb"}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{ylim}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_hline}\NormalTok{(}\DataTypeTok{yintercept=}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{notebook_files/figure-latex/unnamed-chunk-6-1.pdf}

Percebe-se que uma outra aplicação que acessa a memória causa um impacto
negativo no desempenho que aumenta conforme o uso de memória dessa
aplicação aumenta, até que ela atinge o tamanho da cache ou o tamanho da
primeira aplicação.

A aplicação que usa menos memória faz acessos mais frequentes a cache,
de certa forma se apropriando da cache devido a política de substituição
dar prioridade às linhas mais recentemente acessadas.

Talvez por esse motivo as aplicaçÕes maiores não interfiram tanto,
porque a aplicação menor faz acessos mais frequentes e consegue manter
seu dataset na cache. Um teste interessante seria colocar um delay entre
os acessos da aplicação pequena, próximo a latência de acesso a DRAM,
para que tanto a aplicação que usa cache quanto a que não use exerçam a
mesma pressão na cache. Isso também representaria melhor uma
apresentação real, que lê os dados e faz alguma coisa com eles além de
acumular o valor.

Podemos observar o impacto na outra aplicação devido a essa aplicação
que usa 8 MB.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k_diff }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizeb}\OperatorTok{==}\DecValTok{8}\NormalTok{, temp }\OperatorTok{==}\StringTok{ "tt"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ungroup}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }\KeywordTok{select}\NormalTok{(sizea,cyc_diff) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\KeywordTok{as.factor}\NormalTok{(sizea), }\DataTypeTok{y=}\NormalTok{cyc_diff)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{   }\KeywordTok{theme_bw}\NormalTok{() }\OperatorTok{+}\StringTok{ }\KeywordTok{xlab}\NormalTok{(}\StringTok{"sizea"}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{ylim}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_hline}\NormalTok{(}\DataTypeTok{yintercept=}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{notebook_files/figure-latex/unnamed-chunk-7-1.pdf}
Podemos ver que as aplicações que usam de 1 a 6 MB são pouco afetadas
por essa aplicação de 8 MB, pois elas ganham prioridade sobre a cache.
As aplicações maiores são também pouco afetadas porque já não se
beneficiam da cache, havendo concorrência apenas pela memória principal.

E o que acontece com a aplicação de 8 MB se a aplicação concorrente
utilizar loads não temporais?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k_diff }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizea}\OperatorTok{==}\DecValTok{8}\NormalTok{, temp }\OperatorTok{==}\StringTok{ "tt"} \OperatorTok{|}\StringTok{ }\NormalTok{temp }\OperatorTok{==}\StringTok{ "tn"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ungroup}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }\KeywordTok{select}\NormalTok{(sizeb,cyc_diff,temp) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\KeywordTok{as.factor}\NormalTok{(sizeb), }\DataTypeTok{y=}\NormalTok{cyc_diff, }\DataTypeTok{color=}\NormalTok{temp)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{   }\KeywordTok{theme_bw}\NormalTok{() }\OperatorTok{+}\StringTok{ }\KeywordTok{xlab}\NormalTok{(}\StringTok{"sizeb"}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{ylim}\NormalTok{(}\FloatTok{0.99}\NormalTok{,}\DecValTok{2}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_hline}\NormalTok{(}\DataTypeTok{yintercept=}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{notebook_files/figure-latex/unnamed-chunk-8-1.pdf}

Legal, o desempenho da primeira aplicação quase sempre retorna ao normal
quando a segunda aplicação passa a utilizar loads não temporais. Não
retorna totalmente ao valor original porque ainda há alguma concorrência
por hardware mesmo que não contamine a cache.

Mas o problema é que a aplicação secundária perde muito desempenho ao
utilizar os loads não temporais.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k_diff }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizeb}\OperatorTok{==}\DecValTok{8}\NormalTok{, temp }\OperatorTok{==}\StringTok{ "nt"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ungroup}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }\KeywordTok{select}\NormalTok{(sizea,cyc_diff) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\KeywordTok{as.factor}\NormalTok{(sizea), }\DataTypeTok{y=}\NormalTok{cyc_diff)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{   }\KeywordTok{theme_bw}\NormalTok{() }\OperatorTok{+}\StringTok{ }\KeywordTok{xlab}\NormalTok{(}\StringTok{"sizea"}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{ylim}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{6}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_hline}\NormalTok{(}\DataTypeTok{yintercept=}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{notebook_files/figure-latex/unnamed-chunk-9-1.pdf}

Piora bastante para os valores que cabem na cache. Para 16 MB, o dobro
da cache, piora quase 2 vezes, e para valores maiores piora um pouco.
Quanto exatamente?

teste

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k_diff }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizea}\OperatorTok{==}\DecValTok{256}\NormalTok{,sizeb}\OperatorTok{==}\DecValTok{8}\NormalTok{,temp}\OperatorTok{==}\StringTok{"nt"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ungroup}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }\KeywordTok{select}\NormalTok{(cyc_diff) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{as.numeric}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.277858
\end{verbatim}

27.78\%

A aplicação de 256 MB sozinha perde quanto por usar loads não temporais?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k_diff }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizea}\OperatorTok{==}\DecValTok{256}\NormalTok{,sizeb}\OperatorTok{==}\DecValTok{0}\NormalTok{,temp}\OperatorTok{==}\StringTok{"nt"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ungroup}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }\KeywordTok{select}\NormalTok{(cyc_diff) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{as.numeric}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.254393
\end{verbatim}

Perde 25.4\%. Podemos concluir então que nessa máquina os loads não
temporais possuem uma largura de banda 25.4\% menor, ou algo próximo
disso. Um problema dos testes é que eles não fazem só loads mas load e
acumulação. Também não leva em conta o prefetcher que existe e melhora o
desempenho.

É estranho porque os outros experimentos mostraram que a latência dos
loads não temporais é só 6.3\% pior.

Voltando ao assunto que importa, como a soma dos ciclos das aplicaçÕes
muda conforme os loads mudam de temporal pra não temporal?

Provavelmente tem um jeito de fazer isso com uma linha em R mas como não
sei vou fazer uma gambiarra.

Primeiro vou gerar um dataframe invertido, onde a aplicação A e B do
dataframe original são invertidas.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ktemp <-}\StringTok{ }\NormalTok{k }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizeb }\OperatorTok{!=}\StringTok{ }\DecValTok{0}\NormalTok{);}
\NormalTok{k_inv <-}\StringTok{ }\NormalTok{ktemp;}
\NormalTok{k_inv}\OperatorTok{$}\NormalTok{sizea =}\StringTok{ }\NormalTok{ktemp}\OperatorTok{$}\NormalTok{sizeb}
\NormalTok{k_inv}\OperatorTok{$}\NormalTok{sizeb =}\StringTok{ }\NormalTok{ktemp}\OperatorTok{$}\NormalTok{sizea}
\NormalTok{k_inv}\OperatorTok{$}\NormalTok{temp <-}\StringTok{ }\KeywordTok{replace}\NormalTok{(}\KeywordTok{as.character}\NormalTok{(k_inv}\OperatorTok{$}\NormalTok{temp), k_inv}\OperatorTok{$}\NormalTok{temp }\OperatorTok{==}\StringTok{ "nt"}\NormalTok{,}\StringTok{"tmp"}\NormalTok{)}
\NormalTok{k_inv}\OperatorTok{$}\NormalTok{temp <-}\StringTok{ }\KeywordTok{replace}\NormalTok{(}\KeywordTok{as.character}\NormalTok{(k_inv}\OperatorTok{$}\NormalTok{temp), k_inv}\OperatorTok{$}\NormalTok{temp }\OperatorTok{==}\StringTok{ "tn"}\NormalTok{,}\StringTok{"nt"}\NormalTok{)}
\NormalTok{k_inv}\OperatorTok{$}\NormalTok{temp <-}\StringTok{ }\KeywordTok{replace}\NormalTok{(}\KeywordTok{as.character}\NormalTok{(k_inv}\OperatorTok{$}\NormalTok{temp), k_inv}\OperatorTok{$}\NormalTok{temp }\OperatorTok{==}\StringTok{ "tmp"}\NormalTok{,}\StringTok{"tn"}\NormalTok{)}
\KeywordTok{rm}\NormalTok{(ktemp)}
\end{Highlighting}
\end{Shaded}

Aí juntar os dois dataframes e somar as linhas com fatores iguais.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k_sum <-}\StringTok{ }\KeywordTok{rbind}\NormalTok{(k,k_inv)}
\NormalTok{k_sum <-}\StringTok{ }\NormalTok{k_sum }\OperatorTok{%>%}\StringTok{ }\KeywordTok{group_by}\NormalTok{(sizea,sizeb,temp) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{cyc=}\KeywordTok{sum}\NormalTok{(cyc), }\DataTypeTok{l3m=}\KeywordTok{sum}\NormalTok{(l3m), }\DataTypeTok{l3r=}\KeywordTok{sum}\NormalTok{(l3r), }\DataTypeTok{.groups=}\StringTok{'drop'}\NormalTok{)}
\KeywordTok{rm}\NormalTok{(k_inv)}
\KeywordTok{head}\NormalTok{(k_sum)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 6
##   sizea sizeb temp          cyc    l3m        l3r
##   <dbl> <dbl> <chr>       <dbl>  <dbl>      <dbl>
## 1     1     0 nn    26192683123     0         105
## 2     1     0 nt    26235417668     2          86
## 3     1     0 tn     5030942956 17171  1048576997
## 4     1     0 tt     5030948036 17159  1048577042
## 5     1     1 nn    55232161556    12         265
## 6     1     1 nt    31354854232 17198. 1048577109
\end{verbatim}

Agora gerando um dataframe com a diferença de ciclos para esse dataframe

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#k <- k %>% group_by(sizea,temp) %>% mutate_each(funs(./.[1]), cyc_diff=cyc, l3r_diff=l3r, l3m_diff=l3m, -sizeb)}
\NormalTok{k_sum_diff <-}\StringTok{ }\NormalTok{k_sum }\OperatorTok{%>%}\StringTok{ }\KeywordTok{group_by}\NormalTok{(sizea) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{mutate_each}\NormalTok{(}\KeywordTok{funs}\NormalTok{(.}\OperatorTok{/}\NormalTok{.[}\DecValTok{4}\NormalTok{]), }\DataTypeTok{cyc_diff=}\NormalTok{cyc, }\DataTypeTok{l3r_diff=}\NormalTok{l3r, }\DataTypeTok{l3m_diff=}\NormalTok{l3m, }\OperatorTok{-}\NormalTok{sizeb)}
\CommentTok{# CUIDADO!! GAMBIARRA ESSE [4]}

\KeywordTok{head}\NormalTok{(k_sum_diff)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 9
## # Groups:   sizea [1]
##   sizea sizeb temp          cyc    l3m        l3r cyc_diff     l3r_diff l3m_diff
##   <dbl> <dbl> <chr>       <dbl>  <dbl>      <dbl>    <dbl>        <dbl>    <dbl>
## 1     1     0 nn    26192683123     0         105     5.21 0.000000100  0       
## 2     1     0 nt    26235417668     2          86     5.21 0.0000000820 0.000117
## 3     1     0 tn     5030942956 17171  1048576997     1.00 1.00         1.00    
## 4     1     0 tt     5030948036 17159  1048577042     1    1            1       
## 5     1     1 nn    55232161556    12         265    11.0  0.000000253  0.000699
## 6     1     1 nt    31354854232 17198. 1048577109     6.23 1.00         1.00
\end{verbatim}

E o gráfico da diferença entre a soma dos ciclos para a aplicação A com
tamanho de 8 MB e loads temporais e a aplicação B com loads temporais ou
não temporais para todos os tamanhos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k_sum_diff }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizea}\OperatorTok{==}\DecValTok{8}\NormalTok{, temp }\OperatorTok{==}\StringTok{ "tt"} \OperatorTok{|}\StringTok{ }\NormalTok{temp }\OperatorTok{==}\StringTok{ "tn"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ungroup}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizeb}\OperatorTok{!=}\DecValTok{0}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{select}\NormalTok{(sizeb,cyc_diff,temp) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\KeywordTok{as.factor}\NormalTok{(sizeb), }\DataTypeTok{y=}\NormalTok{cyc_diff, }\DataTypeTok{color=}\NormalTok{temp)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{   }\KeywordTok{theme_bw}\NormalTok{() }\OperatorTok{+}\StringTok{ }\KeywordTok{xlab}\NormalTok{(}\StringTok{"sizeb"}\NormalTok{)}\CommentTok{# + geom_hline(yintercept=1)}
\end{Highlighting}
\end{Shaded}

\includegraphics{notebook_files/figure-latex/unnamed-chunk-15-1.pdf}
Percebe-se que para tamanhos da aplicação B de até 12 MB, o desempenho
agregado das aplicações é piorado por utilizar loads não temporais na
aplicação B. Para valores maiores, há algum ganho. Parece que o ganho é
maior com a aplicação B em 32 MB.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k_sum }\OperatorTok{%>%}\StringTok{ }\KeywordTok{group_by}\NormalTok{(sizea,sizeb) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{mutate_each}\NormalTok{(}\KeywordTok{funs}\NormalTok{(.}\OperatorTok{/}\NormalTok{.[}\DecValTok{4}\NormalTok{]), }\OperatorTok{-}\NormalTok{temp) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizeb }\OperatorTok{>}\StringTok{ }\DecValTok{16}\NormalTok{, sizea}\OperatorTok{==}\DecValTok{8}\NormalTok{, temp}\OperatorTok{==}\StringTok{"tn"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 4 x 6
## # Groups:   sizea, sizeb [4]
##   sizea sizeb temp    cyc    l3m   l3r
##   <dbl> <dbl> <chr> <dbl>  <dbl> <dbl>
## 1     8    32 tn    0.960 0.0291 0.760
## 2     8    64 tn    0.965 0.0375 0.778
## 3     8   128 tn    0.964 0.0341 0.785
## 4     8   256 tn    0.965 0.0363 0.785
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#novamente gambiarra pra normalizar pela temporalidade tt}
\end{Highlighting}
\end{Shaded}

Os dados mostram que com a aplicação A de 8 MB e a aplicação B de 32 MB,
quando a aplicação B usa loads não temporais, a soma dos ciclos de ambas
é 96\% da soma dos ciclos quando ambas usam loads temporais.

Em que casos há mais ganho?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k_sum }\OperatorTok{%>%}\StringTok{ }\KeywordTok{group_by}\NormalTok{(sizea,sizeb) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{mutate_each}\NormalTok{(}\KeywordTok{funs}\NormalTok{(.}\OperatorTok{/}\NormalTok{.[}\DecValTok{4}\NormalTok{]), }\OperatorTok{-}\NormalTok{temp) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(temp}\OperatorTok{==}\StringTok{"tn"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{arrange}\NormalTok{(cyc) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{head}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 10 x 6
## # Groups:   sizea, sizeb [10]
##    sizea sizeb temp    cyc    l3m   l3r
##    <dbl> <dbl> <chr> <dbl>  <dbl> <dbl>
##  1     8    32 tn    0.960 0.0291 0.760
##  2     8   128 tn    0.964 0.0341 0.785
##  3     8    64 tn    0.965 0.0375 0.778
##  4     8   256 tn    0.965 0.0363 0.785
##  5     8    16 tn    0.986 0.0275 0.712
##  6     8     0 tn    0.992 0.862  1.00 
##  7    32     0 tn    0.999 1.00   1.00 
##  8    12     0 tn    1.00  1.00   1.00 
##  9   256     0 tn    1.00  1.00   1.00 
## 10   128     0 tn    1.00  1.00   1.00
\end{verbatim}

Parece que só pra esses casos mesmo da aplicação A com 8 MB\ldots{}
Estranho.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizea}\OperatorTok{==}\DecValTok{12}\NormalTok{, sizeb}\OperatorTok{==}\DecValTok{256}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 4 x 6
##   sizea sizeb temp          cyc       l3r       l3m
##   <dbl> <dbl> <chr>       <dbl>     <dbl>     <dbl>
## 1    12   256 nn    11653819198       653         2
## 2    12   256 nt    11881340215    113180    112076
## 3    12   256 tn     5315134853 462946106 181492483
## 4    12   256 tt     5877529299 462951439 210380194
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizeb}\OperatorTok{==}\DecValTok{12}\NormalTok{, sizea}\OperatorTok{==}\DecValTok{256}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 4 x 6
##   sizea sizeb temp         cyc       l3r       l3m
##   <dbl> <dbl> <chr>      <dbl>     <dbl>     <dbl>
## 1   256    12 nn    6440536052    479153       100
## 2   256    12 nt    6451173345    504304    423584
## 3   256    12 tn    5538857975 252163698 252153913
## 4   256    12 tt    5524320386 252168893 252159063
\end{verbatim}

Realmente\ldots{} quando com 256 MB usa loads não temporais perde
desempenho demais. Aqueles 25.4\% observados acabaram pesando na soma

E se eu corrigisse os valores considerando que os loads não temporais
não tivessem uma largura de banda 25.4\% menor? Será que é válido fazer
isso?

Primeiro, será que essa diferença é consistente?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ k_diff }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizea}\OperatorTok{==}\DecValTok{256}\NormalTok{, temp}\OperatorTok{==}\StringTok{"nt"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 15 x 9
## # Groups:   sizea [1]
##    sizea sizeb temp          cyc    l3r    l3m cyc_diff l3r_diff    l3m_diff
##    <dbl> <dbl> <chr>       <dbl>  <dbl>  <dbl>    <dbl>    <dbl>       <dbl>
##  1   256     0 nt    6207997400  480655     85     1.25  0.00191 0.000000337
##  2   256     1 nt    6215740589  481025    178     1.26  0.00191 0.000000706
##  3   256     2 nt    6217040983  481343    676     1.26  0.00191 0.00000268 
##  4   256     3 nt    6214300161  481023   1782     1.26  0.00191 0.00000707 
##  5   256     4 nt    6215547557  481211   4040     1.26  0.00191 0.0000160  
##  6   256     5 nt    6215547204  481051   6630     1.26  0.00191 0.0000263  
##  7   256     6 nt    6216885161  480361   8460     1.26  0.00190 0.0000336  
##  8   256     7 nt    6218760643  481229  54238     1.26  0.00191 0.000215   
##  9   256     8 nt    6324128173  390248 358812     1.28  0.00155 0.00142    
## 10   256    12 nt    6451173345  504304 423584     1.30  0.00200 0.00168    
## 11   256    16 nt    6496314627  499759 411761     1.31  0.00198 0.00163    
## 12   256    32 nt    6538652496  511105 442531     1.32  0.00203 0.00175    
## 13   256    64 nt    6555333584  512057 446283     1.32  0.00203 0.00177    
## 14   256   128 nt    6535967204  501213 446441     1.32  0.00199 0.00177    
## 15   256   256 nt    6568638642. 491640 418728     1.33  0.00195 0.00166
\end{verbatim}

Parece que na verdade quando tem outra thread usando a memória também
essa diferença é maior.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ k_diff }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizea}\OperatorTok{==}\DecValTok{256}\NormalTok{, temp}\OperatorTok{==}\StringTok{"nt"} \OperatorTok{|}\StringTok{ }\NormalTok{temp}\OperatorTok{==}\StringTok{"nn"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ungroup}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }\KeywordTok{select}\NormalTok{(sizeb,cyc_diff,temp) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\KeywordTok{as.factor}\NormalTok{(sizeb), }\DataTypeTok{y=}\NormalTok{cyc_diff, }\DataTypeTok{color=}\NormalTok{temp)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{   }\KeywordTok{theme_bw}\NormalTok{() }\OperatorTok{+}\StringTok{ }\KeywordTok{xlab}\NormalTok{(}\StringTok{"sizeb"}\NormalTok{) }\CommentTok{#+ geom_hline(yintercept=1)}
\end{Highlighting}
\end{Shaded}

\includegraphics{notebook_files/figure-latex/unnamed-chunk-21-1.pdf}
Então parece que quando eu tenho uma thread só indo na memória, quando
ela passa de temporal pra não temporal fica 25\% mais lenta, mas se
também tem outra thread indo na memória, fica em torno de 30\% de
diferença.

Fazendo uma análise conservadora e multiplicando os ciclos das
aplicações com load não temporal por 0.8:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k_corr <-}\StringTok{ }\NormalTok{k }\OperatorTok{%>%}\StringTok{ }\KeywordTok{transform}\NormalTok{(}\DataTypeTok{cyc=}\KeywordTok{ifelse}\NormalTok{(temp}\OperatorTok{==}\StringTok{"nt"} \OperatorTok{|}\StringTok{ }\NormalTok{temp}\OperatorTok{==}\StringTok{"nn"}\NormalTok{, cyc}\OperatorTok{*}\NormalTok{(}\FloatTok{0.8}\NormalTok{), cyc)) }
\end{Highlighting}
\end{Shaded}

E repetindo a análise de antes até chegar na diferença de ciclos da soma
das aplicações:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ktemp <-}\StringTok{ }\NormalTok{k_corr }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizeb }\OperatorTok{!=}\StringTok{ }\DecValTok{0}\NormalTok{);}
\NormalTok{k_inv <-}\StringTok{ }\NormalTok{ktemp;}
\NormalTok{k_inv}\OperatorTok{$}\NormalTok{sizea =}\StringTok{ }\NormalTok{ktemp}\OperatorTok{$}\NormalTok{sizeb}
\NormalTok{k_inv}\OperatorTok{$}\NormalTok{sizeb =}\StringTok{ }\NormalTok{ktemp}\OperatorTok{$}\NormalTok{sizea}
\NormalTok{k_inv}\OperatorTok{$}\NormalTok{temp <-}\StringTok{ }\KeywordTok{replace}\NormalTok{(}\KeywordTok{as.character}\NormalTok{(k_inv}\OperatorTok{$}\NormalTok{temp), k_inv}\OperatorTok{$}\NormalTok{temp }\OperatorTok{==}\StringTok{ "nt"}\NormalTok{,}\StringTok{"tmp"}\NormalTok{)}
\NormalTok{k_inv}\OperatorTok{$}\NormalTok{temp <-}\StringTok{ }\KeywordTok{replace}\NormalTok{(}\KeywordTok{as.character}\NormalTok{(k_inv}\OperatorTok{$}\NormalTok{temp), k_inv}\OperatorTok{$}\NormalTok{temp }\OperatorTok{==}\StringTok{ "tn"}\NormalTok{,}\StringTok{"nt"}\NormalTok{)}
\NormalTok{k_inv}\OperatorTok{$}\NormalTok{temp <-}\StringTok{ }\KeywordTok{replace}\NormalTok{(}\KeywordTok{as.character}\NormalTok{(k_inv}\OperatorTok{$}\NormalTok{temp), k_inv}\OperatorTok{$}\NormalTok{temp }\OperatorTok{==}\StringTok{ "tmp"}\NormalTok{,}\StringTok{"tn"}\NormalTok{)}
\KeywordTok{rm}\NormalTok{(ktemp)}

\NormalTok{k_corr_diff <-}\StringTok{ }\NormalTok{k_corr }\OperatorTok{%>%}\StringTok{ }\KeywordTok{group_by}\NormalTok{(sizea) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{mutate_each}\NormalTok{(}\KeywordTok{funs}\NormalTok{(.}\OperatorTok{/}\NormalTok{.[}\DecValTok{4}\NormalTok{]), }\DataTypeTok{cyc_diff=}\NormalTok{cyc, }\DataTypeTok{l3r_diff=}\NormalTok{l3r, }\DataTypeTok{l3m_diff=}\NormalTok{l3m, }\OperatorTok{-}\NormalTok{sizeb)}

\NormalTok{k_corr_sum <-}\StringTok{ }\KeywordTok{rbind}\NormalTok{(k_corr,k_inv)}
\NormalTok{k_corr_sum <-}\StringTok{ }\NormalTok{k_corr_sum }\OperatorTok{%>%}\StringTok{ }\KeywordTok{group_by}\NormalTok{(sizea,sizeb,temp) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{cyc=}\KeywordTok{sum}\NormalTok{(cyc), }\DataTypeTok{l3m=}\KeywordTok{sum}\NormalTok{(l3m), }\DataTypeTok{l3r=}\KeywordTok{sum}\NormalTok{(l3r), }\DataTypeTok{.groups=}\StringTok{'drop'}\NormalTok{)}
\KeywordTok{rm}\NormalTok{(k_inv)}

\NormalTok{k_corr_sum_diff <-}\StringTok{ }\NormalTok{k_corr_sum }\OperatorTok{%>%}\StringTok{ }\KeywordTok{group_by}\NormalTok{(sizea) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{mutate_each}\NormalTok{(}\KeywordTok{funs}\NormalTok{(.}\OperatorTok{/}\NormalTok{.[}\DecValTok{4}\NormalTok{]), }\DataTypeTok{cyc_diff=}\NormalTok{cyc, }\DataTypeTok{l3r_diff=}\NormalTok{l3r, }\DataTypeTok{l3m_diff=}\NormalTok{l3m, }\OperatorTok{-}\NormalTok{sizeb)}
\NormalTok{k_corr_sum_diff }\OperatorTok{%>%}\StringTok{ }\KeywordTok{arrange}\NormalTok{(cyc_diff) }\CommentTok{#%>% head()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 840 x 9
## # Groups:   sizea [14]
##    sizea sizeb temp         cyc       l3m        l3r cyc_diff l3r_diff l3m_diff
##    <dbl> <dbl> <chr>      <dbl>     <dbl>      <dbl>    <dbl>    <dbl>    <dbl>
##  1     8     0 tn    4775711654   8790854  919309255    0.992     1.00    0.862
##  2    32     0 tn    4862898142 234157290  290523125    0.999     1.00    1.00 
##  3    12     0 tn    4929112452 180823041  462943778    1.00      1.00    1.00 
##  4   256     0 tn    4948380790 252155587  252163055    1.00      1.00    1.00 
##  5   128     0 tn    4912307273 250149731  252186289    1.00      1.00    1.00 
##  6     7     0 tn    5434345105    174827 1126152972    1.00      1.00    0.957
##  7     5     0 tn    5009177553     97417 1038493458    1.00      1.00    0.996
##  8     3     0 tn    4953188766     53963 1032193283    1.00      1.00    1.00 
##  9     2     0 tn    5031351329     35259 1048577101    1.00      1.00    0.995
## 10     1     0 tn    5030942956     17171 1048576997    1.00      1.00    1.00 
## # ... with 830 more rows
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k_corr_sum_diff }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizea}\OperatorTok{==}\DecValTok{8}\NormalTok{, temp }\OperatorTok{==}\StringTok{ "tt"} \OperatorTok{|}\StringTok{ }\NormalTok{temp }\OperatorTok{==}\StringTok{ "tn"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ungroup}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizeb}\OperatorTok{!=}\DecValTok{0}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{select}\NormalTok{(sizeb,cyc_diff,temp) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\KeywordTok{as.factor}\NormalTok{(sizeb), }\DataTypeTok{y=}\NormalTok{cyc_diff, }\DataTypeTok{color=}\NormalTok{temp)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{   }\KeywordTok{theme_bw}\NormalTok{() }\OperatorTok{+}\StringTok{ }\KeywordTok{xlab}\NormalTok{(}\StringTok{"sizeb"}\NormalTok{) }\CommentTok{# + geom_hline(yintercept=1)}
\end{Highlighting}
\end{Shaded}

\includegraphics{notebook_files/figure-latex/unnamed-chunk-24-1.pdf}

Há ganhos para aplicação de 8 MB quando a segunda aplicação tem a partir
de 12 MB.

Como são os ganhos para segunda aplicação não temporal de 256 MB de
acordo com o tamanho da primeira aplicação?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k_corr_sum_diff }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(sizeb}\OperatorTok{==}\DecValTok{256}\NormalTok{, temp }\OperatorTok{==}\StringTok{ "tt"} \OperatorTok{|}\StringTok{ }\NormalTok{temp }\OperatorTok{==}\StringTok{ "tn"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ungroup}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }\KeywordTok{select}\NormalTok{(sizea,cyc_diff,temp) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\KeywordTok{as.factor}\NormalTok{(sizea), }\DataTypeTok{y=}\NormalTok{cyc_diff, }\DataTypeTok{color=}\NormalTok{temp)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{   }\KeywordTok{theme_bw}\NormalTok{() }\OperatorTok{+}\StringTok{ }\KeywordTok{xlab}\NormalTok{(}\StringTok{"sizea"}\NormalTok{) }\CommentTok{#+ geom_hline(yintercept=1)}
\end{Highlighting}
\end{Shaded}

\includegraphics{notebook_files/figure-latex/unnamed-chunk-25-1.pdf}

Tem mais ganho para 8 MB mesmo, mas também algum ganho significativo até
32 MB.

Mas sei lá também\ldots{} não dá pra confiar muito nesses resultados de
tanto de gambiarra que eu tive que fazer.

\end{document}
